let shares =
  [|
    0.163849;
    0.062571;
    0.055568;
    0.041384;
    0.039253;
    0.037665;
    0.026324;
    0.023146;
    0.019743;
    0.019314;
    0.018890;
    0.018619;
    0.018578;
    0.016937;
    0.016835;
    0.016647;
    0.016161;
    0.015994;
    0.015485;
    0.012702;
    0.010868;
    0.010867;
    0.010867;
    0.010865;
    0.010864;
    0.010798;
    0.010796;
    0.010734;
    0.010699;
    0.010601;
    0.010597;
    0.010135;
    0.009085;
    0.008670;
    0.008366;
    0.007741;
    0.006079;
    0.005388;
    0.004332;
    0.004112;
    0.004056;
    0.004005;
    0.003689;
    0.003641;
    0.003628;
    0.003546;
    0.003478;
    0.003466;
    0.003436;
    0.003341;
    0.003338;
    0.003277;
    0.003240;
    0.002870;
    0.002674;
    0.002377;
    0.002267;
    0.002227;
    0.002211;
    0.002089;
    0.001947;
    0.001929;
    0.001906;
    0.001827;
    0.001800;
    0.001732;
    0.001694;
    0.001512;
    0.001481;
    0.001439;
    0.001437;
    0.001384;
    0.001377;
    0.001370;
    0.001359;
    0.001349;
    0.001333;
    0.001331;
    0.001282;
    0.001274;
    0.001268;
    0.001255;
    0.001187;
    0.001185;
    0.001165;
    0.001137;
    0.001085;
    0.001080;
    0.001021;
    0.000959;
    0.000950;
    0.000936;
    0.000929;
    0.000928;
    0.000912;
    0.000890;
    0.000825;
    0.000820;
    0.000776;
    0.000764;
    0.000759;
    0.000744;
    0.000738;
    0.000715;
    0.000702;
    0.000684;
    0.000675;
    0.000662;
    0.000657;
    0.000656;
    0.000656;
    0.000607;
    0.000598;
    0.000597;
    0.000590;
    0.000573;
    0.000555;
    0.000553;
    0.000553;
    0.000550;
    0.000538;
    0.000537;
    0.000520;
    0.000509;
    0.000504;
    0.000494;
    0.000484;
    0.000481;
    0.000472;
    0.000468;
    0.000465;
    0.000459;
    0.000458;
    0.000454;
    0.000447;
    0.000440;
    0.000429;
    0.000424;
    0.000403;
    0.000393;
    0.000388;
    0.000386;
    0.000378;
    0.000374;
    0.000370;
    0.000366;
    0.000364;
    0.000362;
    0.000341;
    0.000320;
    0.000319;
    0.000317;
    0.000316;
    0.000314;
    0.000311;
    0.000296;
    0.000295;
    0.000289;
    0.000287;
    0.000276;
    0.000274;
    0.000265;
    0.000262;
    0.000261;
    0.000249;
    0.000248;
    0.000243;
    0.000242;
    0.000240;
    0.000239;
    0.000239;
    0.000238;
    0.000232;
    0.000231;
    0.000219;
    0.000215;
    0.000212;
    0.000212;
    0.000209;
    0.000204;
    0.000199;
    0.000198;
    0.000197;
    0.000192;
    0.000188;
    0.000186;
    0.000182;
    0.000182;
    0.000175;
    0.000174;
    0.000173;
    0.000171;
    0.000169;
    0.000153;
    0.000153;
    0.000152;
    0.000149;
    0.000148;
    0.000147;
    0.000144;
    0.000143;
    0.000143;
    0.000141;
    0.000135;
    0.000135;
    0.000133;
    0.000132;
    0.000129;
    0.000128;
    0.000125;
    0.000123;
    0.000122;
    0.000122;
    0.000117;
    0.000117;
    0.000115;
    0.000114;
    0.000111;
    0.000111;
    0.000108;
    0.000106;
    0.000105;
    0.000105;
    0.000104;
    0.000104;
    0.000102;
    0.000101;
    0.000101;
    0.000101;
    0.000098;
    0.000096;
    0.000096;
    0.000095;
    0.000094;
    0.000094;
    0.000093;
    0.000092;
    0.000092;
    0.000092;
    0.000092;
    0.000090;
    0.000090;
    0.000089;
    0.000088;
    0.000087;
    0.000086;
    0.000085;
    0.000085;
    0.000084;
    0.000084;
    0.000083;
    0.000078;
    0.000078;
    0.000077;
    0.000076;
    0.000074;
    0.000073;
    0.000071;
    0.000069;
    0.000069;
    0.000068;
    0.000067;
    0.000067;
    0.000066;
    0.000065;
    0.000065;
    0.000064;
    0.000064;
    0.000063;
    0.000063;
    0.000063;
    0.000062;
    0.000062;
    0.000061;
    0.000061;
    0.000060;
    0.000060;
    0.000060;
    0.000059;
    0.000059;
    0.000058;
    0.000058;
    0.000058;
    0.000058;
    0.000056;
    0.000054;
    0.000053;
    0.000052;
    0.000052;
    0.000051;
    0.000050;
    0.000049;
    0.000049;
    0.000049;
    0.000047;
    0.000047;
    0.000045;
    0.000044;
    0.000044;
    0.000044;
    0.000043;
    0.000043;
    0.000042;
    0.000042;
    0.000041;
    0.000041;
    0.000041;
    0.000040;
    0.000040;
    0.000040;
    0.000039;
    0.000038;
    0.000038;
    0.000037;
    0.000037;
    0.000037;
    0.000037;
    0.000037;
    0.000036;
    0.000034;
    0.000034;
    0.000034;
    0.000034;
    0.000034;
    0.000034;
    0.000034;
    0.000033;
    0.000033;
    0.000031;
    0.000031;
    0.000031;
    0.000030;
    0.000030;
    0.000030;
    0.000030;
    0.000030;
    0.000030;
    0.000028;
    0.000028;
    0.000028;
    0.000028;
    0.000028;
    0.000028;
    0.000028;
    0.000028;
    0.000028;
    0.000027;
    0.000027;
    0.000027;
    0.000027;
    0.000027;
    0.000026;
    0.000026;
    0.000026;
    0.000025;
    0.000025;
    0.000025;
    0.000025;
    0.000025;
    0.000025;
    0.000025;
    0.000025;
    0.000024;
    0.000024;
    0.000024;
    0.000024;
    0.000024;
    0.000024;
    0.000024;
    0.000023;
    0.000023;
    0.000023;
    0.000023;
    0.000023;
    0.000023;
    0.000022;
    0.000022;
    0.000022;
    0.000022;
    0.000022;
    0.000022;
    0.000021;
    0.000021;
    0.000021;
    0.000021;
    0.000021;
    0.000020;
    0.000019;
    0.000019;
    0.000019;
    0.000019;
    0.000018;
    0.000018;
    0.000018;
    0.000018;
    0.000018;
    0.000017;
    0.000017;
    0.000017;
    0.000017;
  |]

(** [shards shard_count] computes an assignement of consecutive disjoint shards according
    to the mainnet stake distribution.

    The assignment is computed by iterating on bakers by decreasing stake, assigning them
    the fraction of the [shard_count] shards corresponding to their stake. *)
let shards shard_count =
  (* not what will be implemented but we don't care too much *)
  let exception Done in
  let rem = ref shard_count in
  let assignement = ref [] in
  try
    Array.iteri
      (fun i share ->
        if !rem = 0 then raise Done
        else
          let shards =
            min !rem (int_of_float (ceil (share *. float shard_count)))
          in
          rem := !rem - shards ;
          assignement := (i, shards) :: !assignement)
      shares ;
    Format.printf "%d remaining" !rem ;
    assert false
  with Done ->
    let _, acc =
      List.fold_left
        (fun (tot, acc) (attester, shard_count) ->
          let itv = {Interval.lo = tot - shard_count; hi = tot - 1} in
          (tot - shard_count, (attester, itv) :: acc))
        (2048, [])
        !assignement
    in
    acc

let mainnet_shard_assignment = Array.of_list (shards 2048)

let uniform attester_count =
  if attester_count > 2048 || attester_count <= 0 then
    invalid_arg "Stake.uniform" ;
  let rest = 2048 mod attester_count in
  let size = 2048 / attester_count in
  Seq.append
    (Seq.init (attester_count - 1) (fun i ->
         let itv = {Interval.lo = i * size; hi = ((i + 1) * size) - 1} in
         (i, itv)))
    (List.to_seq
       [
         ( attester_count - 1,
           {
             Interval.lo = (attester_count - 1) * size;
             hi = (attester_count * size) + rest - 1;
           } );
       ])
  |> Array.of_seq

let uniform_shard_assignment = uniform (Array.length mainnet_shard_assignment)
