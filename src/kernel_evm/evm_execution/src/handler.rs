// SPDX-FileCopyrightText: 2022-2023 TriliTech <contact@trili.tech>
//
// SPDX-License-Identifier: MIT

//! Handle details of EVM runtime
//!
//! The interface between SputnikVM and the kernel. This includes interface
//! to storage, account balances, block constants, _and transaction state_.

use crate::account_storage::{
    account_path, AccountStorageError, EthereumAccount, EthereumAccountStorage,
    CODE_HASH_DEFAULT,
};
use crate::storage;
use crate::transaction::{
    begin_transaction, commit_transaction, rollback_transaction, TransactionContext,
};
use crate::EthereumError;
use crate::PrecompileSet;
use alloc::borrow::Cow;
use alloc::rc::Rc;
use core::convert::Infallible;
use debug::debug_msg;
use evm::executor::stack::Log;
use evm::gasometer::Gasometer;
use evm::{
    Capture, Config, Context, CreateScheme, ExitError, ExitFatal, ExitReason, ExitRevert,
    ExitSucceed, Handler, Opcode, Stack, Transfer,
};
use host::runtime::Runtime;
use primitive_types::{H160, H256, U256};
use sha3::{Digest, Keccak256};
use tezos_ethereum::block::BlockConstants;

/// Maximum transaction stack depth.
const MAXIMUM_TRANSACTION_DEPTH: usize = 1024_usize;

/// Outcome of making the [EvmHandler] run an Ethereum transaction
///
/// Be it contract -call, -create or simple transfer, the handler will update the world
/// state in durable storage _and_ produce a summary of the outcome that will be needed
/// for creating a transaction receipt.
#[derive(Debug, Eq, PartialEq)]
pub struct ExecutionOutcome {
    /// How much gas was used for processing an entire transaction.
    pub gas_used: u64,
    /// Whether the transaction succeeded or not.
    ///  - In case of transfer-, whether the funds were transferred
    ///  - In case of call-, whether toplevel call returned or stopped (success), or
    ///    something else (revert, invalid code, etc. are non-successes).
    ///  - In case of create-, whethere a new contract was created or not.
    pub is_success: bool,
    /// In case of create- transactions, this field contains address of the new contract
    pub new_address: Option<H160>,
    /// Logs generated by the transaction.
    pub logs: Vec<Log>,
}

/// Map an execution Result to an ExecutionOutcome
///
/// Some variants of EthereumError should be treated as errors for the purpose of
/// EVM execution, because they stop execution and direct control flow back to caller
/// (like an error). The same circumstances (eg running out of gas) are not errors as
/// such for the users of the toplevel transaction functions called by `run_transaction`.
/// At that point same errors just indicate a failed transaction.
///
/// TODO: add logs to the outcome. See issue: <https://gitlab.com/tezos/tezos/-/issues/4870>
fn map_execution_outcome(
    gas_used: u64,
    result: Result<(ExitReason, Option<H160>, Vec<u8>), EthereumError>,
) -> Result<ExecutionOutcome, EthereumError> {
    match result {
        Ok((reason, new_address, _)) => Ok(ExecutionOutcome {
            gas_used,
            is_success: reason.is_succeed(),
            new_address,
            logs: vec![],
        }),
        Err(EthereumError::EthereumAccountError(_error)) => Ok(ExecutionOutcome {
            gas_used,
            is_success: false,
            new_address: None,
            logs: vec![],
        }),
        Err(EthereumError::MachineExitError(_error)) => Ok(ExecutionOutcome {
            gas_used,
            is_success: false,
            new_address: None,
            logs: vec![],
        }),
        Err(EthereumError::PrecompileFailed(_error)) => Ok(ExecutionOutcome {
            gas_used,
            is_success: false,
            new_address: None,
            logs: vec![],
        }),
        Err(EthereumError::CallRevert) => Ok(ExecutionOutcome {
            gas_used,
            is_success: false,
            new_address: None,
            logs: vec![],
        }),
        Err(err) => Err(err),
    }
}

fn ethereum_error_to_exit_reason(
    exit_reason: EthereumError,
    raise_to_fatal: bool,
) -> ExitReason {
    match exit_reason {
        EthereumError::MachineExitError(err) if raise_to_fatal => {
            ExitReason::Fatal(ExitFatal::CallErrorAsFatal(err))
        }
        EthereumError::MachineExitError(err) => ExitReason::Error(err),
        EthereumError::FatalMachineError(err) => ExitReason::Fatal(err),
        EthereumError::CallRevert => ExitReason::Revert(ExitRevert::Reverted),
        _ => ExitReason::Fatal(ExitFatal::Other(Cow::from(
            "Internal error in EVM interpreter",
        ))),
    }
}

/// Utility function to map Rust Results of contract call to the SputnikVM Capture type
fn result_to_capture<T>(
    result: Result<(ExitReason, Vec<u8>), EthereumError>,
) -> Capture<(ExitReason, Vec<u8>), T> {
    match result {
        Ok((reason, v)) => Capture::Exit((reason, v)),
        Err(err) => Capture::Exit((ethereum_error_to_exit_reason(err, true), vec![])),
    }
}

/// Utility function to map Rust Results of contract create to SputnikVM Capture type
fn create_result_to_capture<T>(
    result: Result<(ExitReason, Option<H160>, Vec<u8>), EthereumError>,
) -> Capture<(ExitReason, Option<H160>, Vec<u8>), T> {
    match result {
        Ok((reason, address_opt, v)) => Capture::Exit((reason, address_opt, v)),
        Err(err) => {
            Capture::Exit((ethereum_error_to_exit_reason(err, false), None, vec![]))
        }
    }
}

/// The implementation of the SputnikVM [Handler] trait
pub struct EvmHandler<'a, Host: Runtime> {
    /// The host
    host: &'a mut Host,
    /// The ethereum accounts storage
    evm_account_storage: &'a mut EthereumAccountStorage,
    /// The original caller initiating the toplevel transaction
    origin: H160,
    /// The constants for the current block
    pub block: &'a BlockConstants,
    /// The precompiled functions
    precompiles: &'a dyn PrecompileSet<Host>,
    /// The gasometer for measuring and keeping track of gas usage
    gasometer: Gasometer<'a>,
    /// The configuration, eg, London or Frontier for execution
    config: &'a Config,
}

#[allow(unused_variables)]
impl<'a, Host: Runtime> EvmHandler<'a, Host> {
    /// Create a new handler to suit a new, initial EVM call context
    pub fn new(
        host: &'a mut Host,
        evm_account_storage: &'a mut EthereumAccountStorage,
        origin: H160,
        block: &'a BlockConstants,
        config: &'a Config,
        precompiles: &'a dyn PrecompileSet<Host>,
        gas_limit: u64,
    ) -> Self {
        Self {
            host,
            evm_account_storage,
            origin,
            block,
            config,
            precompiles,
            gasometer: Gasometer::<'a>::new(gas_limit, config),
        }
    }

    /// Get the total amount of gas used for the duration of the handlers
    /// lifetime.
    pub fn gas_used(&self) -> u64 {
        self.gasometer.total_used_gas()
    }

    /// Execute a SputnikVM runtime with this handler
    fn execute(
        &mut self,
        runtime: &mut evm::Runtime,
    ) -> Result<ExitReason, EthereumError> {
        match runtime.run(self) {
            Capture::Exit(ExitReason::Succeed(exit_succeed)) => {
                Ok(ExitReason::Succeed(exit_succeed))
            }
            Capture::Exit(ExitReason::Revert(exit_revert)) => {
                Ok(ExitReason::Revert(exit_revert))
            }
            Capture::Exit(ExitReason::Error(error)) => {
                Err(EthereumError::MachineExitError(error))
            }
            Capture::Exit(ExitReason::Fatal(error)) => {
                Err(EthereumError::FatalMachineError(error))
            }
            Capture::Trap(_) => Err(EthereumError::InternalTrapError),
        }
    }

    fn create_address(&mut self, scheme: CreateScheme) -> H160 {
        match scheme {
            CreateScheme::Create2 {
                caller,
                code_hash,
                salt,
            } => {
                let mut hasher = Keccak256::new();
                hasher.update([0xff]);
                hasher.update(caller);
                hasher.update(salt);
                hasher.update(code_hash);
                H256::from_slice(hasher.finalize().as_slice()).into()
            }
            CreateScheme::Legacy { caller } => {
                let nonce = self.get_nonce(caller).unwrap_or(U256::zero());
                let mut stream = rlp::RlpStream::new_list(2);
                stream.append(&caller);
                stream.append(&nonce);
                H256::from_slice(Keccak256::digest(&stream.out()).as_slice()).into()
            }
            CreateScheme::Fixed(address) => address,
        }
    }

    /// Execute a transfer between two accounts
    fn execute_transfer(
        &mut self,
        from: H160,
        to: H160,
        value: U256,
        gas_limit: Option<u64>,
    ) -> Result<(), EthereumError> {
        debug_msg!(self.host, "Executing a transfer");

        // TODO let transfers cost gas
        // issue: https://gitlab.com/tezos/tezos/-/issues/5118

        if value == U256::zero() {
            // Nothing to transfer so succeeds by default
            Ok(())
        } else if let Some(mut from_account) = self.get_account(from) {
            let mut to_account = self.get_or_create_account(to)?;

            from_account.balance_remove(self.host, value)?;
            to_account
                .balance_add(self.host, value)
                .map_err(EthereumError::from)
        } else {
            debug_msg!(self.host, "'from' account {:?} is empty", from);
            // Accounts of zero balance by default, so this must be
            // an underflow.
            Err(EthereumError::EthereumAccountError(
                AccountStorageError::BalanceUnderflow,
            ))
        }
    }

    /// Create a contract
    ///
    /// Performs the actual contract creation for both transactions initiated
    /// by external accounts and contract creation initiated through contract
    /// execution.
    fn execute_create(
        &mut self,
        caller: H160,
        scheme: CreateScheme,
        value: U256,
        initial_code: Vec<u8>,
        gas_limit: Option<u64>,
    ) -> Result<(ExitReason, Option<H160>, Vec<u8>), EthereumError> {
        debug_msg!(self.host, "Executing a contract create");

        let address = self.create_address(scheme);

        // TODO: mark `caller` and `address` as hot for gas calculation
        // issue: https://gitlab.com/tezos/tezos/-/issues/4866

        if self.evm_account_storage.transaction_depth() >= MAXIMUM_TRANSACTION_DEPTH {
            return Err(EthereumError::MachineExitError(ExitError::CallTooDeep));
        }

        let context = Context {
            address,
            caller,
            apparent_value: value,
        };

        begin_transaction(self.host, self.evm_account_storage)?;

        // TODO: check that target address isn't already in use (must contain no code and a zero
        // nonce)
        // issue: https://gitlab.com/tezos/tezos/-/issues/4865

        if let Err(error) = self.execute_transfer(caller, address, value, gas_limit) {
            debug_msg!(
                self.host,
                "Failed transfer for create, funds: {:?}, from: {:?}, to: {:?}",
                value,
                caller,
                address
            );
            rollback_transaction(self.host, self.evm_account_storage)?;
            return Err(error);
        }

        self.increment_nonce(caller)?;

        let mut runtime = evm::Runtime::new(
            Rc::new(initial_code),
            Rc::new(Vec::new()),
            context,
            self.config,
        );

        let result = self.execute(&mut runtime);

        match result {
            Ok(r @ ExitReason::Succeed(_)) => {
                debug_msg!(
                    self.host,
                    "Execution succeeded (with {:?}). Committing transaction.",
                    r
                );

                // TODO: Verify the odd situations of:
                //  - Succeed with STOP instruction (or just stopped because of
                //    no more instructions). That doesn't return anything, so
                //    we end up with an empty contract.
                //  - Succeed with "suicide" - that doesn't produce a useful
                //    contract either.
                // issue: https://gitlab.com/tezos/tezos/-/issues/4867

                let code_out = runtime.machine().return_value();

                // TODO: EIP-3541 check first byte of `code_out`. If it is 0xEF,
                // we should cancel deployment.
                // issue: https://gitlab.com/tezos/tezos/-/issues/4867

                // NOTE: If necessary for the rollup we can check the size of the
                // contract as well to prevent contracts too large.
                // (No issue for this - this may not be an issue at all..)

                // TODO: Check gas vs cost of deploying the contract
                // issue: https://gitlab.com/tezos/tezos/-/issues/5118

                commit_transaction(self.host, self.evm_account_storage)?;

                self.set_contract_code(address, code_out)?;

                Ok((r, Some(address), vec![]))
            }
            Ok(r @ ExitReason::Revert(ExitRevert::Reverted)) => {
                debug_msg!(
                    self.host,
                    "Contract create reverted. Roll back transaction."
                );

                rollback_transaction(self.host, self.evm_account_storage)?;
                Ok((r, None, vec![]))
            }
            Ok(ExitReason::Error(error)) => {
                debug_msg!(
                    self.host,
                    "Running returned an error: {:?}. Roll back transaction.",
                    error
                );
                rollback_transaction(self.host, self.evm_account_storage)?;
                Err(EthereumError::MachineExitError(error))
            }
            Ok(ExitReason::Fatal(fatal_error)) => {
                debug_msg!(
                    self.host,
                    "Running returned a fatal error: {:?}. Roll back transaction.",
                    fatal_error
                );
                rollback_transaction(self.host, self.evm_account_storage)?;
                Err(EthereumError::FatalMachineError(fatal_error))
            }
            Err(err) => {
                debug_msg!(
                    self.host,
                    "Running returned an error: {:?} Roll back transaction.",
                    err
                );
                rollback_transaction(self.host, self.evm_account_storage)?;
                Err(err)
            }
        }
    }

    /// Call a contract
    ///
    /// Perform the actual contract execution - works both for executing an
    /// Ethereum transaction as initiated by an external account or as aresult
    /// of any of the -CALL instructions.
    #[allow(clippy::too_many_arguments)]
    fn execute_call(
        &mut self,
        address: H160,
        transfer: Option<Transfer>,
        input: Vec<u8>,
        gas_limit: Option<u64>,
        is_static: bool,
        transaction_context: TransactionContext,
    ) -> Result<(ExitReason, Vec<u8>), EthereumError> {
        debug_msg!(
            self.host,
            "Executing contract call at depth: {}",
            self.evm_account_storage.transaction_depth()
        );

        if self.evm_account_storage.transaction_depth() > MAXIMUM_TRANSACTION_DEPTH {
            debug_msg!(self.host, "Execution beyond the call limit of 1024");
            return Err(EthereumError::MachineExitError(ExitError::CallTooDeep));
        }

        // TODO: check gas
        // issue: https://gitlab.com/tezos/tezos/-/issues/5120

        // TODO: add transfer to gas (if it is there)
        // issue: https://gitlab.com/tezos/tezos/-/issues/5121

        begin_transaction(self.host, self.evm_account_storage)?;

        // TODO: touch address - mark as hot for gas calculation
        // issue: https://gitlab.com/tezos/tezos/-/issues/4866

        if let Some(transfer) = transfer {
            if let Err(error) = self.execute_transfer(
                transaction_context.context.caller,
                address,
                transfer.value,
                gas_limit,
            ) {
                rollback_transaction(self.host, self.evm_account_storage)?;
                return Err(error);
            }
        }

        self.increment_nonce(transaction_context.context.caller)?;

        if let Some(precompile_result) = self.precompiles.execute(
            self,
            address,
            &input,
            gas_limit,
            &transaction_context.context,
            is_static,
        ) {
            match precompile_result {
                Ok(precompile_output) => {
                    commit_transaction(self.host, self.evm_account_storage)?;

                    match precompile_output.exit_status {
                        ExitSucceed::Stopped => {
                            Ok((ExitReason::Succeed(ExitSucceed::Stopped), vec![]))
                        }
                        ExitSucceed::Returned => Ok((
                            ExitReason::Succeed(ExitSucceed::Returned),
                            precompile_output.output,
                        )),
                        ExitSucceed::Suicided => {
                            Ok((ExitReason::Succeed(ExitSucceed::Suicided), vec![]))
                        }
                    }
                }
                Err(e) => {
                    rollback_transaction(self.host, self.evm_account_storage)?;
                    Err(EthereumError::PrecompileFailed(e))
                }
            }
        } else {
            let code = self.code(address);

            let mut runtime = evm::Runtime::new(
                Rc::new(code),
                Rc::new(input),
                transaction_context.context,
                self.config,
            );

            let result = self.execute(&mut runtime);

            match result {
                Ok(r @ ExitReason::Succeed(ExitSucceed::Stopped)) => {
                    debug_msg!(
                        self.host,
                        "Contract execution stopped (success). Committing transaction."
                    );
                    commit_transaction(self.host, self.evm_account_storage)?;
                    Ok((r, vec![]))
                }
                Ok(r @ ExitReason::Succeed(ExitSucceed::Returned)) => {
                    debug_msg!(
                        self.host,
                        "Contract execution returned (success). Committing transaction."
                    );
                    commit_transaction(self.host, self.evm_account_storage)?;
                    Ok((r, runtime.machine().return_value()))
                }
                Ok(r @ ExitReason::Succeed(ExitSucceed::Suicided)) => {
                    debug_msg!(
                        self.host,
                        "Contract execution suicided (success). Committing transaction."
                    );
                    // TODO: transfer to beneficiary and erase contract
                    // issue: https://gitlab.com/tezos/tezos/-/issues/4902

                    commit_transaction(self.host, self.evm_account_storage)?;
                    Ok((r, vec![]))
                }
                Ok(r @ ExitReason::Revert(ExitRevert::Reverted)) => {
                    debug_msg!(
                        self.host,
                        "Contract execution reverted. Rolling back transaction."
                    );
                    rollback_transaction(self.host, self.evm_account_storage)?;
                    Ok((r, vec![]))
                }
                Ok(ExitReason::Error(error)) => {
                    debug_msg!(self.host, "Exiting call execution because of error: {:?}. Rolling back transaction.", error);
                    rollback_transaction(self.host, self.evm_account_storage)?;
                    Err(EthereumError::MachineExitError(error))
                }
                Ok(ExitReason::Fatal(fatal_error)) => {
                    debug_msg!(self.host, "Exiting call execution because of fatal error: {:?}. Rolling back transaction.", fatal_error);
                    rollback_transaction(self.host, self.evm_account_storage)?;
                    Err(EthereumError::FatalMachineError(fatal_error))
                }
                Err(err) => {
                    debug_msg!(self.host, "Exiting call execution because of general error: {:?}. Rolling back transaction.", err);
                    rollback_transaction(self.host, self.evm_account_storage)?;
                    Err(err)
                }
            }
        }
    }

    /// Perform a contract call transaction
    pub fn call_contract(
        &mut self,
        caller: H160,
        callee: H160,
        value: Option<U256>,
        input: Vec<u8>,
        gas_limit: Option<u64>,
        is_static: bool,
    ) -> Result<ExecutionOutcome, EthereumError> {
        let result = self.execute_call(
            callee,
            value.map(|value| Transfer {
                source: caller,
                target: callee,
                value,
            }),
            input,
            gas_limit,
            is_static,
            TransactionContext::new(caller, callee, value.unwrap_or(U256::zero())),
        );

        map_execution_outcome(self.gas_used(), result.map(|(x, y)| (x, None, y)))
    }

    /// Perform a create-contract transaction
    pub fn create_contract(
        &mut self,
        caller: H160,
        value: Option<U256>,
        input: Vec<u8>,
        gas_limit: Option<u64>,
    ) -> Result<ExecutionOutcome, EthereumError> {
        let default_create_scheme = CreateScheme::Legacy { caller };

        let result = self.execute_create(
            caller,
            default_create_scheme,
            value.unwrap_or(U256::zero()),
            input,
            gas_limit,
        );

        map_execution_outcome(self.gas_used(), result)
    }

    /// Perform a transfer transaction
    pub fn transfer(
        &mut self,
        from: H160,
        to: H160,
        value: U256,
        gas_limit: Option<u64>,
    ) -> Result<ExecutionOutcome, EthereumError> {
        begin_transaction(self.host, self.evm_account_storage)?;

        self.increment_nonce(from)?;

        // TODO gas cost - it costs a fixed amount transferring funds

        let transfer_cost = self.config.gas_transaction_call;

        if let Err(error) = self.execute_transfer(from, to, value, gas_limit) {
            rollback_transaction(self.host, self.evm_account_storage)?;
            Ok(ExecutionOutcome {
                gas_used: transfer_cost,
                is_success: false,
                new_address: None,
                logs: vec![],
            })
        } else {
            commit_transaction(self.host, self.evm_account_storage)?;
            Ok(ExecutionOutcome {
                gas_used: transfer_cost,
                is_success: true,
                new_address: None,
                logs: vec![],
            })
        }
    }

    fn get_or_create_account(
        &self,
        address: H160,
    ) -> Result<EthereumAccount, EthereumError> {
        self.evm_account_storage
            .get_or_create_account(self.host, &account_path(&address)?)
            .map_err(EthereumError::from)
    }

    fn get_account(&self, address: H160) -> Option<EthereumAccount> {
        // Note: if we get an error we cannot report this to SputnikVM as the return types
        // for functions that use _this_ function don't support errors. Rather than do
        // error handling in all those functions (and those we'll write in the future), we
        // do the error handling here.
        if let Ok(path) = account_path(&address) {
            self.evm_account_storage
                .get_account(self.host, &path)
                .ok()
                .flatten()
        } else {
            debug_msg!(
                self.host,
                "Failed to get account path for EVM handler get_account"
            );
            None
        }
    }

    fn get_original_account(&self, address: H160) -> Option<EthereumAccount> {
        // Note, there is no way to recover from an error when creating the
        // account path. At this point we are being called from SputnikVM and
        // it does not allow for this to fail, so we just return None.
        if let Ok(path) = account_path(&address) {
            self.evm_account_storage
                .get_original_account(self.host, &path)
                .ok()
                .flatten()
        } else {
            debug_msg!(
                self.host,
                "Failed to get account path for EVM handler get_original_account"
            );
            None
        }
    }

    fn increment_nonce(&mut self, address: H160) -> Result<(), EthereumError> {
        match account_path(&address) {
            Ok(path) => {
                let mut account = self
                    .evm_account_storage
                    .get_or_create_account(self.host, &path)?;
                account
                    .increment_nonce(self.host)
                    .map_err(EthereumError::from)
            }
            Err(err) => {
                debug_msg!(
                    self.host,
                    "Failed to increment nonce for account {:?}",
                    address
                );
                Err(EthereumError::from(err))
            }
        }
    }

    fn set_contract_code(
        &mut self,
        address: H160,
        code: Vec<u8>,
    ) -> Result<(), EthereumError> {
        self.get_or_create_account(address)?
            .set_code(self.host, &code)
            .map_err(EthereumError::from)
    }

    fn get_nonce(&self, address: H160) -> Result<U256, EthereumError> {
        self.get_account(address)
            .map(|account| account.nonce(self.host).map_err(EthereumError::from))
            .unwrap_or(Ok(U256::zero()))
    }

    /// Borrow a reference to the host - needed for eg precompiled contracts
    pub fn borrow_host(&mut self) -> &'_ mut Host {
        self.host
    }
}

#[allow(unused_variables)]
impl<'a, Host: Runtime> Handler for EvmHandler<'a, Host> {
    type CreateInterrupt = Infallible;
    type CreateFeedback = Infallible;
    type CallInterrupt = Infallible;
    type CallFeedback = Infallible;

    fn balance(&self, address: H160) -> U256 {
        self.get_account(address)
            .and_then(|a| a.balance(self.host).ok())
            .unwrap_or(U256::zero())
    }

    fn code_size(&self, address: H160) -> U256 {
        self.get_account(address)
            .and_then(|a| a.code_size(self.host).ok())
            .unwrap_or(U256::zero())
    }

    fn code_hash(&self, address: H160) -> H256 {
        self.get_account(address)
            .and_then(|a| a.code_hash(self.host).ok())
            .unwrap_or(CODE_HASH_DEFAULT)
    }

    fn code(&self, address: H160) -> Vec<u8> {
        // TODO: mark address as hot
        // issue: https://gitlab.com/tezos/tezos/-/issues/4866

        self.get_account(address)
            .and_then(|a| a.code(self.host).ok())
            .unwrap_or_default()
    }

    fn storage(&self, address: H160, index: H256) -> H256 {
        self.get_account(address)
            .and_then(|a| a.get_storage(self.host, &index).ok())
            .unwrap_or(H256::zero())
    }

    fn original_storage(&self, address: H160, index: H256) -> H256 {
        self.get_original_account(address)
            .and_then(|a| a.get_storage(self.host, &index).ok())
            .unwrap_or(H256::zero())
    }

    fn gas_left(&self) -> U256 {
        // TODO: https://gitlab.com/tezos/tezos/-/issues/5321
        // Use the gasometer to find amount of gas left for current execution
        U256::zero() // STUB
    }

    fn gas_price(&self) -> U256 {
        self.block.gas_price
    }

    fn origin(&self) -> H160 {
        self.origin
    }

    fn block_hash(&self, number: U256) -> H256 {
        storage::blocks::get_block_hash(self.host, number)
            .unwrap_or_else(|_| panic!("Block with number {} doesn't exist", number))
    }

    fn block_number(&self) -> U256 {
        self.block.number
    }

    fn block_coinbase(&self) -> H160 {
        self.block.coinbase
    }

    fn block_timestamp(&self) -> U256 {
        self.block.timestamp
    }

    fn block_difficulty(&self) -> U256 {
        self.block.difficulty
    }

    fn block_gas_limit(&self) -> U256 {
        self.block.gas_limit.into()
    }

    fn block_base_fee_per_gas(&self) -> U256 {
        self.block.base_fee_per_gas
    }

    fn chain_id(&self) -> U256 {
        self.block.chain_id
    }

    fn exists(&self, address: H160) -> bool {
        self.code_size(address) > U256::zero()
    }

    fn deleted(&self, address: H160) -> bool {
        // TODO: https://gitlab.com/tezos/tezos/-/issues/5321
        // If a contract suicides it gets deleted. Keep track of those deletionsin the handler
        false // STUB
    }

    fn is_cold(&self, address: H160, index: Option<H256>) -> bool {
        // TODO: https://gitlab.com/tezos/tezos/-/issues/4866
        false // STUB until issue above has been fixed
    }

    fn set_storage(
        &mut self,
        address: H160,
        index: H256,
        value: H256,
    ) -> Result<(), ExitError> {
        let mut account = self.get_or_create_account(address).map_err(|_| {
            ExitError::Other(Cow::from("Could not get account for set_storage"))
        })?;
        account
            .set_storage(self.host, &index, &value)
            .map_err(|_| ExitError::Other(Cow::from("Could not set_storage in handler")))
    }

    fn log(
        &mut self,
        address: H160,
        topics: Vec<H256>,
        data: Vec<u8>,
    ) -> Result<(), ExitError> {
        // TODO: issue: https://gitlab.com/tezos/tezos/-/issues/4870
        Ok(()) // STUB until issue above has been fixed
    }

    fn mark_delete(&mut self, address: H160, target: H160) -> Result<(), ExitError> {
        // TODO: https://gitlab.com/tezos/tezos/-/issues/5321
        // Contract suicide will mark a contract for deletion.
        Ok(()) // STUB
    }

    fn create(
        &mut self,
        caller: H160,
        scheme: CreateScheme,
        value: U256,
        init_code: Vec<u8>,
        target_gas: Option<u64>,
    ) -> Capture<(ExitReason, Option<H160>, Vec<u8>), Self::CreateInterrupt> {
        create_result_to_capture(
            self.execute_create(caller, scheme, value, init_code, target_gas),
        )
    }

    fn call(
        &mut self,
        code_address: H160,
        transfer: Option<Transfer>,
        input: Vec<u8>,
        target_gas: Option<u64>,
        is_static: bool,
        context: Context,
    ) -> Capture<(ExitReason, Vec<u8>), Self::CallInterrupt> {
        result_to_capture(self.execute_call(
            code_address,
            transfer,
            input,
            target_gas,
            is_static,
            TransactionContext::from_context(context),
        ))
    }

    fn pre_validate(
        &mut self,
        context: &Context,
        opcode: Opcode,
        stack: &Stack,
    ) -> Result<(), ExitError> {
        if let Some(cost) = evm::gasometer::static_opcode_cost(opcode) {
            self.gasometer.record_cost(cost)
        } else {
            let (cost, _target, memory_cost) = evm::gasometer::dynamic_opcode_cost(
                context.address,
                opcode,
                stack,
                false,
                self.config,
                &self,
            )?;

            self.gasometer.record_dynamic_cost(cost, memory_cost)
        }
    }

    fn create_feedback(
        &mut self,
        _feedback: Self::CreateFeedback,
    ) -> Result<(), ExitError> {
        // TODO: issue: https://gitlab.com/tezos/tezos/-/issues/4872
        Ok(()) // this is a stub
    }
}

#[cfg(test)]
mod test {
    use super::*;
    use crate::account_storage::init_account_storage;
    use crate::precompiles;
    use evm::Config;
    use primitive_types::{H160, H256};
    use std::cmp::Ordering;
    use std::str::FromStr;
    use tezos_smart_rollup_mock::MockHost;

    fn set_code<'a>(
        handler: &mut EvmHandler<'a, MockHost>,
        address: &H160,
        code: Vec<u8>,
    ) {
        let mut account = handler.get_or_create_account(*address).unwrap();
        account.set_code(handler.borrow_host(), &code).unwrap();
    }

    fn get_balance<'a>(handler: &mut EvmHandler<'a, MockHost>, address: &H160) -> U256 {
        let account = handler.get_or_create_account(*address).unwrap();
        account.balance(handler.borrow_host()).unwrap()
    }

    fn set_balance<'a>(
        handler: &mut EvmHandler<'a, MockHost>,
        address: &H160,
        new_balance: U256,
    ) {
        let mut account = handler.get_or_create_account(*address).unwrap();
        let old_balance = account.balance(handler.borrow_host()).unwrap();
        match old_balance.cmp(&new_balance) {
            Ordering::Greater => account
                .balance_remove(handler.borrow_host(), old_balance - new_balance)
                .unwrap(),
            Ordering::Less => account
                .balance_add(handler.borrow_host(), new_balance - old_balance)
                .unwrap(),
            Ordering::Equal => (),
        }
    }

    fn get_durable_slot<'a>(
        handler: &mut EvmHandler<'a, MockHost>,
        address: &H160,
        index: &H256,
    ) -> H256 {
        let account = handler.get_or_create_account(*address).unwrap();
        account.get_storage(handler.borrow_host(), index).unwrap()
    }

    #[test]
    fn legacy_create_to_correct_address() {
        let mut mock_runtime = MockHost::default();
        let block = BlockConstants::first_block();
        let precompiles = precompiles::precompile_set::<MockHost>();
        let mut evm_account_storage = init_account_storage().unwrap();
        let config = Config::london();
        let gas_limit = 1000_u64;

        // This is a randomly generated address. It has been used for testing legacy address
        // generation with zero nonce using Ethereum. To replicate (with new address):
        // - generate a fresh Ethereum account (on Rinkeby or other test net)
        // - make sure it has eth (transfer from faucet)
        // - check nonce is zero (or bump nonce accordingly below)
        // - create a new contract. Any contract will do.
        // - check address of new contract - it is `expected_result` below.
        let caller: H160 =
            H160::from_str("9bbfed6889322e016e0a02ee459d306fc19545d8").unwrap();

        let mut handler = EvmHandler::new(
            &mut mock_runtime,
            &mut evm_account_storage,
            caller,
            &block,
            &config,
            &precompiles,
            gas_limit,
        );

        let result = handler.create_address(CreateScheme::Legacy { caller });

        let expected_result: H160 =
            H160::from_str("43a61f3f4c73ea0d444c5c1c1a8544067a86219b").unwrap();

        assert_eq!(result, expected_result);
    }

    #[test]
    fn create2_to_correct_address() {
        let mut mock_runtime = MockHost::default();
        let block = BlockConstants::first_block();
        let precompiles = precompiles::precompile_set::<MockHost>();
        let mut evm_account_storage = init_account_storage().unwrap();
        let config = Config::london();
        let gas_limit = 1000_u64;
        let caller: H160 =
            H160::from_str("9bbfed6889322e016e0a02ee459d306fc19545d8").unwrap();

        let mut handler = EvmHandler::new(
            &mut mock_runtime,
            &mut evm_account_storage,
            caller,
            &block,
            &config,
            &precompiles,
            gas_limit,
        );

        let code_hash: H256 = CODE_HASH_DEFAULT;
        let salt: H256 = H256::zero();

        let result = handler.create_address(CreateScheme::Create2 {
            caller,
            code_hash,
            salt,
        });

        let expected_result: H160 =
            H160::from_str("0687a12da0ffa0a64a28c9512512b8ae8870b7ea").unwrap();

        assert_eq!(result, expected_result);
    }

    #[test]
    fn create2_to_correct_address_nonzero_salt() {
        let mut mock_runtime = MockHost::default();
        let block = BlockConstants::first_block();
        let precompiles = precompiles::precompile_set::<MockHost>();
        let mut evm_account_storage = init_account_storage().unwrap();
        let config = Config::london();
        let gas_limit = 1000_u64;
        let caller: H160 =
            H160::from_str("9bbfed6889322e016e0a02ee459d306fc19545d8").unwrap();

        let mut handler = EvmHandler::new(
            &mut mock_runtime,
            &mut evm_account_storage,
            caller,
            &block,
            &config,
            &precompiles,
            gas_limit,
        );

        let code_hash: H256 = CODE_HASH_DEFAULT;
        let salt: H256 = H256::from_str(
            "0000000000000000000000000000000000000000000000000000000000000001",
        )
        .unwrap();

        let result = handler.create_address(CreateScheme::Create2 {
            caller,
            code_hash,
            salt,
        });

        let expected_result: H160 =
            H160::from_str("dbd0b036a125995a83d0ab020656a8355abac612").unwrap();

        assert_eq!(result, expected_result);
    }

    #[test]
    fn origin_instruction_returns_origin_address() {
        let mut mock_runtime = MockHost::default();
        let block = BlockConstants::first_block();
        let precompiles = precompiles::precompile_set::<MockHost>();
        let mut evm_account_storage = init_account_storage().unwrap();
        let config = Config::london();
        let gas_limit = 1000_u64;
        let caller = H160::from_low_u64_be(28349_u64);

        // We use an origin distinct from caller for testing purposes
        let origin = H160::from_low_u64_be(117_u64);

        let mut handler = EvmHandler::new(
            &mut mock_runtime,
            &mut evm_account_storage,
            origin,
            &block,
            &config,
            &precompiles,
            gas_limit,
        );

        let address = H160::from_low_u64_be(213_u64);
        let input = vec![0_u8];
        let gas_limit: Option<u64> = None;
        let is_static = false;
        let transaction_context = TransactionContext::new(caller, address, U256::zero());
        let transfer: Option<Transfer> = None;
        let code: Vec<u8> = vec![
            Opcode::ORIGIN.as_u8(), // Push the 32(!) byte origin on to stack (this is "the value")
            Opcode::PUSH1.as_u8(), // Push a zero valued word onto stack (this is "the address")
            0_u8,
            Opcode::MSTORE.as_u8(), // Store "the value" at "the address"
            Opcode::PUSH1.as_u8(),  // Push value 2 onto stack - this is "number of bytes"
            32_u8,
            Opcode::PUSH1.as_u8(), // Push value 0 onto stack - this is "the address" again
            0_u8,
            Opcode::RETURN.as_u8(), // Return "number of bytes" at "the address" in the RETURNBUFFER
        ];

        set_code(&mut handler, &address, code);

        let result = handler.execute_call(
            address,
            transfer,
            input,
            gas_limit,
            is_static,
            transaction_context,
        );

        match result {
            Ok(result) => {
                let expected_result = (
                    ExitReason::Succeed(ExitSucceed::Returned),
                    H256::from(origin).0.to_vec(),
                );
                assert_eq!(result, expected_result);
                assert_eq!(handler.gas_used(), 17);
            }
            Err(err) => {
                panic!("Expected Ok, but got {:?}", err);
            }
        }
    }

    #[test]
    fn contract_call_produces_correct_output() {
        let mut mock_runtime = MockHost::default();
        let block = BlockConstants::first_block();
        let precompiles = precompiles::precompile_set::<MockHost>();
        let mut evm_account_storage = init_account_storage().unwrap();
        let config = Config::london();
        let gas_limit = 1000_u64;
        let caller = H160::from_low_u64_be(28349_u64);

        let mut handler = EvmHandler::new(
            &mut mock_runtime,
            &mut evm_account_storage,
            caller,
            &block,
            &config,
            &precompiles,
            gas_limit,
        );

        let address = H160::from_low_u64_be(213_u64);
        let input = vec![0_u8];
        let gas_limit: Option<u64> = None;
        let is_static = false;
        let transaction_context = TransactionContext::new(caller, address, U256::zero());
        let transfer: Option<Transfer> = None;
        let code: Vec<u8> = vec![
            Opcode::PUSH32.as_u8(), // Push a 32 byte word onto stack (this is "the value")
            0xFF_u8,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            Opcode::PUSH1.as_u8(), // Push a zero valued word onto stack (this is "the address")
            0_u8,
            Opcode::MSTORE.as_u8(), // Store "the value" at "the address"
            Opcode::PUSH1.as_u8(),  // Push value 2 onto stack - this is "number of bytes"
            2_u8,
            Opcode::PUSH1.as_u8(), // Push value 0 onto stack - this is "the address" again
            0_u8,
            Opcode::RETURN.as_u8(), // Return "number of bytes" at "the address" in the RETURNBUFFER
        ];

        set_code(&mut handler, &address, code);

        let result = handler.execute_call(
            address,
            transfer,
            input,
            gas_limit,
            is_static,
            transaction_context,
        );

        match result {
            Ok(result) => {
                let expected_result = (
                    ExitReason::Succeed(ExitSucceed::Returned),
                    vec![0xFF_u8, 0x01_u8],
                );
                assert_eq!(result, expected_result);
                assert_eq!(handler.gas_used(), 18);
            }
            Err(err) => {
                panic!("Expected Ok, but got {:?}", err);
            }
        }
    }

    // This test will fail because it blows the stack with the Rust default
    // stack size. This could be indication that we should do issue
    // https://gitlab.com/tezos/tezos/-/issues/4888
    // use RUST_MIN_STACK=<value> cargo test -p evm-kernel --features testing
    // with <value> set to 104857600 or something similar in size
    #[ignore]
    #[test]
    fn contract_call_fails_beyond_max_transaction_depth() {
        let mut mock_runtime = MockHost::default();
        let block = BlockConstants::first_block();
        let precompiles = precompiles::precompile_set::<MockHost>();
        let mut evm_account_storage = init_account_storage().unwrap();
        let config = Config::london();
        let gas_limit = 1000_u64;
        let caller = H160::from_low_u64_be(2340);

        let mut handler = EvmHandler::new(
            &mut mock_runtime,
            &mut evm_account_storage,
            caller,
            &block,
            &config,
            &precompiles,
            gas_limit,
        );

        let input_value = U256::from(2026_u32);
        let mut input = [0_u8; 32];
        input_value.to_big_endian(&mut input);

        let address = H160::from_low_u64_be(118);
        let gas_limit: Option<u64> = None;
        let is_static = false;
        let transaction_context = TransactionContext::new(caller, address, U256::zero());
        let transfer: Option<Transfer> = None;
        let code: Vec<u8> = vec![
            // get input data, subtract one and prepare as argument to nested call
            Opcode::PUSH1.as_u8(),
            1,
            Opcode::PUSH1.as_u8(),
            0, // call data offset
            Opcode::CALLDATALOAD.as_u8(),
            Opcode::SUB.as_u8(),
            // check if result is zero - if so, skip to return
            Opcode::DUP1.as_u8(),
            Opcode::ISZERO.as_u8(),
            Opcode::PUSH1.as_u8(),
            28_u8, // to JPMDEST
            Opcode::JUMPI.as_u8(),
            // store result in memory to use as call argument
            Opcode::PUSH1.as_u8(),
            0,
            Opcode::MSTORE.as_u8(),
            // set call parameters
            Opcode::PUSH1.as_u8(),
            0, // return size
            Opcode::PUSH1.as_u8(),
            0, // return offset
            Opcode::PUSH1.as_u8(),
            32_u8, // arg size
            Opcode::PUSH1.as_u8(),
            0, // arg offset
            Opcode::PUSH1.as_u8(),
            0,                       // value
            Opcode::ADDRESS.as_u8(), // address
            Opcode::PUSH1.as_u8(),
            0,                    // gas
            Opcode::CALL.as_u8(), // call self
            // when we get here we are done
            Opcode::JUMPDEST.as_u8(),
            Opcode::PUSH1.as_u8(),
            0, // return data size
            Opcode::PUSH1.as_u8(),
            0, // return data offset
            Opcode::RETURN.as_u8(),
        ];

        set_code(&mut handler, &address, code);

        let result = handler.execute_call(
            address,
            transfer,
            input.to_vec(),
            gas_limit,
            is_static,
            transaction_context,
        );

        match result {
            Ok(result) => {
                panic!("Expected to fail, but got Ok({:?})", result);
            }
            Err(EthereumError::FatalMachineError(ExitFatal::CallErrorAsFatal(
                ExitError::CallTooDeep,
            ))) => {
                assert_eq!(handler.gas_used(), 5);
            }
            Err(err) => {
                panic!("Expected a too-many-calls error, but got {:?}", err);
            }
        }
    }

    // This test will fail because it blows the stack with the Rust default
    // stack size. This could be indication that we should do issue
    // https://gitlab.com/tezos/tezos/-/issues/4888
    // use RUST_MIN_STACK=<value> cargo test -p evm-kernel --features testing
    // with <value> set to 104857600 or something similar in size
    #[ignore]
    #[test]
    fn contract_call_succeeds_at_maximum_transaction_depth() {
        let mut mock_runtime = MockHost::default();
        let block = BlockConstants::first_block();
        let precompiles = precompiles::precompile_set::<MockHost>();
        let mut evm_account_storage = init_account_storage().unwrap();
        let config = Config::london();
        let gas_limit = 1000_u64;
        let caller = H160::from_low_u64_be(8213);

        let mut handler = EvmHandler::new(
            &mut mock_runtime,
            &mut evm_account_storage,
            caller,
            &block,
            &config,
            &precompiles,
            gas_limit,
        );

        let input_value = U256::from(1025_u32); // transaction depth for contract below is callarg - 1
        let mut input = [0_u8; 32];
        input_value.to_big_endian(&mut input);

        let address = H160::from_low_u64_be(12389);
        let gas_limit: Option<u64> = None;
        let is_static = false;
        let transaction_context = TransactionContext::new(caller, address, U256::zero());
        let transfer: Option<Transfer> = None;
        let code: Vec<u8> = vec![
            // get input data, subtract one and prepare as argument to nested call
            Opcode::PUSH1.as_u8(),
            1,
            Opcode::PUSH1.as_u8(),
            0, // call data offset
            Opcode::CALLDATALOAD.as_u8(),
            Opcode::SUB.as_u8(),
            // check if result is zero - if so, skip to return
            Opcode::DUP1.as_u8(),
            Opcode::ISZERO.as_u8(),
            Opcode::PUSH1.as_u8(),
            28_u8, // to JPMDEST
            Opcode::JUMPI.as_u8(),
            // store result in memory to use as call argument
            Opcode::PUSH1.as_u8(),
            0,
            Opcode::MSTORE.as_u8(),
            // set call parameters
            Opcode::PUSH1.as_u8(),
            0, // return size
            Opcode::PUSH1.as_u8(),
            0, // return offset
            Opcode::PUSH1.as_u8(),
            32_u8, // arg size
            Opcode::PUSH1.as_u8(),
            0, // arg offset
            Opcode::PUSH1.as_u8(),
            0,                       // value
            Opcode::ADDRESS.as_u8(), // address
            Opcode::PUSH1.as_u8(),
            0,                    // gas
            Opcode::CALL.as_u8(), // call self
            // when we get here we are done
            Opcode::JUMPDEST.as_u8(),
            Opcode::PUSH1.as_u8(),
            0, // return data size
            Opcode::PUSH1.as_u8(),
            0, // return data offset
            Opcode::RETURN.as_u8(),
        ];

        set_code(&mut handler, &address, code);

        let result = handler.execute_call(
            address,
            transfer,
            input.to_vec(),
            gas_limit,
            is_static,
            transaction_context,
        );

        match result {
            Ok(result) => {
                let expected_result =
                    (ExitReason::Succeed(ExitSucceed::Returned), vec![]);
                assert_eq!(result, expected_result);
                assert_eq!(handler.gas_used(), 5);
            }
            Err(err) => {
                panic!("Expected Ok, but got {:?}", err);
            }
        }
    }

    #[test]
    fn contract_can_use_durable_storage() {
        let mut mock_runtime = MockHost::default();
        let block = BlockConstants::first_block();
        let precompiles = precompiles::precompile_set::<MockHost>();
        let mut evm_account_storage = init_account_storage().unwrap();
        let config = Config::london();
        let gas_limit = 100000_u64;
        let caller = H160::from_low_u64_be(444);

        let mut handler = EvmHandler::new(
            &mut mock_runtime,
            &mut evm_account_storage,
            caller,
            &block,
            &config,
            &precompiles,
            gas_limit,
        );

        let address = H160::from_low_u64_be(312);
        let input: Vec<u8> = vec![0_u8];
        let gas_limit: Option<u64> = None;
        let is_static = false;
        let transaction_context = TransactionContext::new(caller, address, U256::zero());
        let transfer: Option<Transfer> = None;
        let code: Vec<u8> = vec![
            Opcode::PUSH1.as_u8(),
            46_u8,
            Opcode::PUSH1.as_u8(),
            0_u8,
            Opcode::SSTORE.as_u8(),
            Opcode::PUSH1.as_u8(),
            0_u8,
            Opcode::SLOAD.as_u8(),
            Opcode::PUSH1.as_u8(),
            1_u8,
            Opcode::SLOAD.as_u8(),
            Opcode::PUSH1.as_u8(),
            0,
            Opcode::RETURN.as_u8(),
        ];

        set_code(&mut handler, &address, code);

        let result = handler.execute_call(
            address,
            transfer,
            input,
            gas_limit,
            is_static,
            transaction_context,
        );

        match result {
            Ok(result) => {
                let expected_result =
                    (ExitReason::Succeed(ExitSucceed::Returned), vec![]);
                assert_eq!(result, expected_result);
                let expected_in_storage = H256::from_str(
                    "000000000000000000000000000000000000000000000000000000000000002e",
                )
                .unwrap();
                assert_eq!(
                    get_durable_slot(&mut handler, &address, &H256::zero()),
                    expected_in_storage
                );
                assert_eq!(handler.gas_used(), 20215);
            }
            Err(err) => {
                panic!("Expected Ok, but got {:?}", err);
            }
        }
    }

    #[test]
    fn contract_create_can_use_durable_storage() {
        let mut mock_runtime = MockHost::default();
        let block = BlockConstants::first_block();
        let precompiles = precompiles::precompile_set::<MockHost>();
        let mut evm_account_storage = init_account_storage().unwrap();
        let config = Config::london();
        let gas_limit = 100000_u64;
        let caller = H160::from_low_u64_be(117);

        let mut handler = EvmHandler::new(
            &mut mock_runtime,
            &mut evm_account_storage,
            caller,
            &block,
            &config,
            &precompiles,
            gas_limit,
        );

        let gas_limit: Option<u64> = None;
        let value = U256::zero();
        let create_scheme = CreateScheme::Legacy { caller };
        let init_code: Vec<u8> = hex::decode("608060405234801561001057600080fd5b50602a600081905550610150806100286000396000f3fe608060405234801561001057600080fd5b50600436106100365760003560e01c80632e64cec11461003b5780636057361d14610059575b600080fd5b610043610075565b60405161005091906100a1565b60405180910390f35b610073600480360381019061006e91906100ed565b61007e565b005b60008054905090565b8060008190555050565b6000819050919050565b61009b81610088565b82525050565b60006020820190506100b66000830184610092565b92915050565b600080fd5b6100ca81610088565b81146100d557600080fd5b50565b6000813590506100e7816100c1565b92915050565b600060208284031215610103576101026100bc565b5b6000610111848285016100d8565b9150509291505056fea26469706673582212204d6c1853cec27824f5dbf8bcd0994714258d22fc0e0dc8a2460d87c70e3e57a564736f6c63430008120033").unwrap();

        let expected_address = handler.create_address(create_scheme);

        let result =
            handler.execute_create(caller, create_scheme, value, init_code, gas_limit);

        match result {
            Ok(result) => {
                let expected_result = (
                    ExitReason::Succeed(ExitSucceed::Returned),
                    Some(expected_address),
                    vec![],
                );
                assert_eq!(result, expected_result);
                assert_eq!(get_durable_slot(&mut handler, &expected_address, &H256::zero()), H256::from_str("000000000000000000000000000000000000000000000000000000000000002a").unwrap());
                assert_eq!(handler.gas_used(), 20131);
            }
            Err(err) => {
                panic!("Expected Ok, but got {:?}", err);
            }
        }
    }

    #[test]
    fn contract_call_does_transfer() {
        let mut mock_runtime = MockHost::default();
        let block = BlockConstants::first_block();
        let precompiles = precompiles::precompile_set::<MockHost>();
        let mut evm_account_storage = init_account_storage().unwrap();
        let config = Config::london();
        let gas_limit = 1000_u64;
        let caller = H160::from_low_u64_be(118);

        let mut handler = EvmHandler::new(
            &mut mock_runtime,
            &mut evm_account_storage,
            caller,
            &block,
            &config,
            &precompiles,
            gas_limit,
        );

        let address = H160::from_low_u64_be(117);
        let input = vec![0_u8];
        let gas_limit: Option<u64> = None;
        let is_static = false;
        let transaction_context =
            TransactionContext::new(caller, address, U256::from(50_u32));
        let transfer: Option<Transfer> = Some(Transfer {
            source: caller,
            target: address,
            value: U256::from(100_u32),
        });
        let code: Vec<u8> = vec![
            Opcode::PUSH1.as_u8(),
            0u8,
            Opcode::PUSH1.as_u8(),
            0u8,
            Opcode::RETURN.as_u8(),
        ];

        set_code(&mut handler, &address, code);
        set_balance(&mut handler, &caller, U256::from(101_u32));

        let result = handler.execute_call(
            address,
            transfer,
            input,
            gas_limit,
            is_static,
            transaction_context,
        );

        match result {
            Ok(result) => {
                let expected_result =
                    (ExitReason::Succeed(ExitSucceed::Returned), vec![]);
                assert_eq!(result, expected_result);
                assert_eq!(get_balance(&mut handler, &address), U256::from(100_u32));
                assert_eq!(get_balance(&mut handler, &caller), U256::from(1_u32));
                assert_eq!(handler.gas_used(), 6);
            }
            Err(err) => {
                panic!("Expected Ok, but got {:?}", err);
            }
        }
    }

    #[test]
    fn no_transfer_when_contract_call_fails() {
        let mut mock_runtime = MockHost::default();
        let block = BlockConstants::first_block();
        let precompiles = precompiles::precompile_set::<MockHost>();
        let mut evm_account_storage = init_account_storage().unwrap();
        let config = Config::london();
        let gas_limit = 50_u64;
        let caller = H160::from_low_u64_be(118_u64);

        let mut handler = EvmHandler::new(
            &mut mock_runtime,
            &mut evm_account_storage,
            caller,
            &block,
            &config,
            &precompiles,
            gas_limit,
        );

        let address = H160::from_low_u64_be(117_u64);
        let input = vec![0_u8];
        let gas_limit: Option<u64> = None;
        let is_static = false;
        let transaction_context = TransactionContext::new(caller, address, U256::zero());
        let transfer: Option<Transfer> = Some(Transfer {
            source: caller,
            target: address,
            value: U256::from(100_u32),
        });
        let code: Vec<u8> = vec![
            Opcode::PUSH1.as_u8(),
            0u8,
            Opcode::PUSH1.as_u8(),
            0u8,
            Opcode::INVALID.as_u8(),
        ];

        set_code(&mut handler, &address, code);
        set_balance(&mut handler, &caller, U256::from(101_u32));

        let result = handler.execute_call(
            address,
            transfer,
            input,
            gas_limit,
            is_static,
            transaction_context,
        );

        match result {
            Ok(result) => {
                panic!("Got Ok, but this was supposed to fail (got {:?})", result);
            }
            // Note: the gasometer treats all invalid opcodes as running out of gas, so with a
            // gasometer installed, we run out of gas. Without the gasometer we get the
            // `DesignatedInvalid` exit error.
            Err(EthereumError::MachineExitError(
                ExitError::DesignatedInvalid | ExitError::OutOfGas,
            )) => {
                assert_eq!(get_balance(&mut handler, &caller), U256::from(101_u32));
                assert_eq!(get_balance(&mut handler, &address), U256::zero());
                assert_eq!(handler.gas_used(), 50);
            }
            Err(err) => {
                panic!("Unexpected error: {:?}", err);
            }
        }
    }

    #[test]
    fn contract_call_fails_when_insufficient_funds_for_transfer() {
        let mut mock_runtime = MockHost::default();
        let block = BlockConstants::first_block();
        let precompiles = precompiles::precompile_set::<MockHost>();
        let mut evm_account_storage = init_account_storage().unwrap();
        let config = Config::london();
        let gas_limit = 1000_u64;
        let caller = H160::from_low_u64_be(523_u64);

        let mut handler = EvmHandler::new(
            &mut mock_runtime,
            &mut evm_account_storage,
            caller,
            &block,
            &config,
            &precompiles,
            gas_limit,
        );

        let address = H160::from_low_u64_be(210_u64);
        let input = vec![0_u8];
        let gas_limit: Option<u64> = None;
        let is_static = false;
        let transaction_context = TransactionContext::new(caller, address, U256::zero());
        let transfer: Option<Transfer> = Some(Transfer {
            source: caller,
            target: address,
            value: U256::from(100_u32),
        });
        let code: Vec<u8> = vec![
            Opcode::PUSH1.as_u8(),
            0u8,
            Opcode::PUSH1.as_u8(),
            0u8,
            Opcode::RETURN.as_u8(),
        ];

        set_code(&mut handler, &address, code);
        set_balance(&mut handler, &caller, U256::from(99_u32));

        let result = handler.execute_call(
            address,
            transfer,
            input,
            gas_limit,
            is_static,
            transaction_context,
        );

        match result {
            Ok(result) => {
                panic!("Got Ok, but this was supposed to fail (got {:?})", result);
            }
            Err(EthereumError::EthereumAccountError(
                AccountStorageError::BalanceUnderflow,
            )) => {
                assert_eq!(get_balance(&mut handler, &caller), U256::from(99_u32));
                assert_eq!(get_balance(&mut handler, &address), U256::zero());
                assert_eq!(handler.gas_used(), 0);
            }
            Err(err) => {
                panic!("Unexpected error: {:?}", err);
            }
        }
    }
}
